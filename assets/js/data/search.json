[ { "title": "C++的函数调用约定(calling convention)", "url": "/posts/C-%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-calling-convention/", "categories": "C++", "tags": "C++", "date": "2021-05-08 02:08:34 +0800", "snippet": "我们在C++中调用函数时，可能很少关注参数是如何入栈，在调用完毕之后又是如何恢复栈的状态的。实际上我们可以通过对于VC++编译器来说，支持下列的调用约定： 关键字 堆栈清理 参数传递 __cdecl 调用方 在堆栈上按相反顺序推送参数（从右到左） __clrcall 不适用 按顺序将参数加载到 CLR 表达式堆栈上（从左到右） __stdcall 被调用方 在堆栈上按相反顺序推送参数（从右到左） ..." }, { "title": "使用std::futured的并行快速排序算法", "url": "/posts/%E4%BD%BF%E7%94%A8std-futured%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/", "categories": "C++", "tags": "C++", "date": "2021-05-08 01:15:45 +0800", "snippet": "快速排序算法我们或多或少都曾了解过。但我们使用的一般都是单线程的版本，对于小规模的数据，尚且可以应付。而对于大规模的数据，单线程的版本就有些力不从心，就为了研究并行的快速排序算法，我们不妨先回顾一下传统的快速排序算法。下面首先用Haskell简单阐述一下基本的快排原理。代码如下：quicksort [] = []quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater) ``where ``lesser = ``filter` `(&amp;lt; p) xs ``greater = ``filte..." }, { "title": "找回了git账号", "url": "/posts/%E6%89%BE%E5%9B%9E%E4%BA%86%E4%BB%A5%E5%89%8D%E7%9A%84git%E8%B4%A6%E5%8F%B7/", "categories": "生活", "tags": "生活", "date": "2021-05-07 03:37:19 +0800", "snippet": "找回了之前的git账号，以后就维护这个blog了。" } ]
