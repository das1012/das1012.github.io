<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://das1012.github.io/</id><title>星光的blog</title><subtitle>分享自己的研究，探索，学习与生活 &amp;&amp; 保持谦卑</subtitle> <updated>2021-05-08T07:30:38+08:00</updated> <author> <name>刘明瑞</name> <uri>https://das1012.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://das1012.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://das1012.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 刘明瑞 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>C++的函数调用约定(calling convention)</title><link href="https://das1012.github.io/posts/C-%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-calling-convention/" rel="alternate" type="text/html" title="C++的函数调用约定(calling convention)" /><published>2021-05-08T02:08:34+08:00</published> <updated>2021-05-08T05:57:32+08:00</updated> <id>https://das1012.github.io/posts/C-%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-calling-convention/</id> <content src="https://das1012.github.io/posts/C-%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-calling-convention/" /> <author> <name>刘明瑞</name> </author> <category term="C++" /> <summary> 我们在C++中调用函数时，可能很少关注参数是如何入栈，在调用完毕之后又是如何恢复栈的状态的。实际上我们可以通过 对于VC++编译器来说，支持下列的调用约定： 关键字 堆栈清理 参数传递 __cdecl 调用方 在堆栈上按相反顺序推送参数（从右到左） __clrcall 不适用 按顺序将参数加载到 CLR 表达式堆栈上（从左到右） __stdcall 被调用方 在堆栈上按相反顺序推送参数（从右到左） __fastcall 被调用方 存储在寄存器中，然后在堆栈上推送 ... </summary> </entry> <entry><title>使用std::futured的并行快速排序算法</title><link href="https://das1012.github.io/posts/%E4%BD%BF%E7%94%A8std-futured%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="使用std::futured的并行快速排序算法" /><published>2021-05-08T01:15:45+08:00</published> <updated>2021-05-08T05:57:32+08:00</updated> <id>https://das1012.github.io/posts/%E4%BD%BF%E7%94%A8std-futured%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id> <content src="https://das1012.github.io/posts/%E4%BD%BF%E7%94%A8std-futured%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /> <author> <name>刘明瑞</name> </author> <category term="C++" /> <summary> 快速排序算法我们或多或少都曾了解过。但我们使用的一般都是单线程的版本，对于小规模的数据，尚且可以应付。而对于大规模的数据，单线程的版本就有些力不从心，就为了研究并行的快速排序算法，我们不妨先回顾一下传统的快速排序算法。下面首先用Haskell简单阐述一下基本的快排原理。 代码如下： quicksort [] = [] quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater) ``where ``lesser = ``filter` `(&amp;lt; p) xs ``greater = ``filter` `(&amp;gt;= p) xs 为了实现快速排序算法，我们需要选择一个基准元素p，将当前数组分为两个子数组，其中lesser数组里面存放小于基准元素p的所有元素，greater存放剩下的... </summary> </entry> <entry><title>找回了git账号</title><link href="https://das1012.github.io/posts/%E6%89%BE%E5%9B%9E%E4%BA%86%E4%BB%A5%E5%89%8D%E7%9A%84git%E8%B4%A6%E5%8F%B7/" rel="alternate" type="text/html" title="找回了git账号" /><published>2021-05-07T03:37:19+08:00</published> <updated>2021-05-08T05:57:32+08:00</updated> <id>https://das1012.github.io/posts/%E6%89%BE%E5%9B%9E%E4%BA%86%E4%BB%A5%E5%89%8D%E7%9A%84git%E8%B4%A6%E5%8F%B7/</id> <content src="https://das1012.github.io/posts/%E6%89%BE%E5%9B%9E%E4%BA%86%E4%BB%A5%E5%89%8D%E7%9A%84git%E8%B4%A6%E5%8F%B7/" /> <author> <name>刘明瑞</name> </author> <category term="生活" /> <summary> 找回了之前的git账号，以后就维护这个blog了。 </summary> </entry> </feed>
