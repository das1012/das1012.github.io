{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/30/hello-world/"},{"title":"test","text":"","link":"/2020/05/01/test/"},{"title":"C++的函数调用约定(calling convention)","text":"我们在C++中调用函数时，可能很少关注参数是如何入栈，在调用完毕之后又是如何恢复栈的状态的。实际上我们可以通过 对于VC++编译器来说，支持下列的调用约定： 关键字 堆栈清理 参数传递 __cdecl 调用方 在堆栈上按相反顺序推送参数（从右到左） __clrcall 不适用 按顺序将参数加载到 CLR 表达式堆栈上（从左到右） __stdcall 被调用方 在堆栈上按相反顺序推送参数（从右到左） __fastcall 被调用方 存储在寄存器中，然后在堆栈上推送 __thiscall 被调用方 已推送到堆栈上;此指针存储在 ECX 中 _vectorcall 被调用方 存储在寄存器中，然后按相反顺序在堆栈上推送（从右到左） 下面分别简单介绍一下上述六个调用约定： __cdecl__cdecl是 C 和C++程序的默认调用约定。 堆栈由调用方清理，所以参数就可以是vararg。__cdecl名称约定如下： int func( int a, double b ) 的函数按如下所示进行修饰：_func 在 ARM 和 x64 处理器上 ，__cdecl被编译器接受，但通常被忽略掉。 按照 ARM 和 x64 上的约定，自变量将尽可能传入寄存器，后续自变量传递到堆栈中（毕竟寄存器就那么几个，对于参数非常多的函数，不得不把一部分参数压到栈中）。 在 x64 代码中，使用 __cdecl来重写 /Gv编译器选项并使用默认 x64 调用约定。 123456789//定义如下结构struct CMyClass { void __cdecl mymethod();};//functionAvoid CMyClass::mymethod() { return; }//functionBvoid __cdecl CMyClass::mymethod() { return; }//functionB 和functionA是等价的 __clrcall__clrcall是微软对C++做的扩展，通过它可以让C++调用C#的函数。通过启用编译器参数(/clr)，可以将所有的函数和函数指针标记。 123456789101112131415161718192021222324252627282930// clrcall2.cpp// compile with: /clrusing namespace System;int __clrcall Func1() { Console::WriteLine(&quot;in Func1&quot;); return 0;}// Func1 hasn&apos;t been used at this point (code has not been generated),// so runtime returns the adddress of a stub to the functionint (__clrcall *pf)() = &amp;Func1;// code calls the function, code generated at difference addressint i = pf(); // comment this line and comparison will passint main() { if (&amp;Func1 == pf) Console::WriteLine(&quot;&amp;Func1 == pf, comparison succeeds&quot;); else Console::WriteLine(&quot;&amp;Func1 != pf, comparison fails&quot;); // even though comparison fails, stub and function call are correct pf(); Func1();}//输出//in Func1//&amp;Func1 != pf, comparison fails//in Func1//in Func1 __stdcall__stdcall一般用于WINAPI中。stdcall是不支持可变参数的。它的名称约定如下： 下划线 () 是名称的前缀。 名称后跟后面是自变量列表中的字节数（采用十进制）的符号 (@)。 因此，声明为 int func( int a, double b ) 的函数按如下所示进行修饰：_func@12 (int + double的字节数) __fastcall__fastcall仅适用于x86架构。面向 ARM 和 x64 体系结构的编译器接受并忽略该关键字;在 x64 芯片上，按照约定，前四个参数在寄存器中传递（如果可能），而其他参数在堆栈上传递。 在 ARM 芯片上，寄存器中可以传递最多四个整数参数和八个浮点参数，而其他参数在堆栈上传递。它的名称约定如下： 声明为 int func( int a, double b ) 的函数按如下所示进行修饰：@func@12 (int + double的字节数) __thiscall__thiscall在 ARM 和 x64 计算机上，编译器接受并忽略它。它由被调用方清理堆栈，自然不支持可变参数。因为C++的类成员函数和其他的函数不同的一点在于成员都有一个this指针，为了处理这种情况，会用到thiscall。 __vectorcall__vectorcall默认也是尽可能多地使用寄存器。相比于fastcall或x64调用约定，它会使用更多的寄存器。但是仅在包含流式处理 SIMD 扩展2（SSE2）和更高版本的 x86 和 x64 处理器上的本机代码中支持 vectorcall调用约定。 使用 vectorcall**加快传递多个浮点或 SIMD 向量参数的函数，并执行利用寄存器中加载的参数的操作。 __vectorcall对于参数类型有严格的要求，具体如下： 可以通过在 __vectorcall函数中注册来传递三种参数：整数类型值、矢量类型值和同类矢量聚合（HVA）值。 整数类型满足两个要求：它适合处理器的本机寄存器大小（例如，x86 计算机上的 4 个字节或 x64 计算机上的 8 个字节），而且它可以转换成与寄存器长度一样的整数，并且不用更改其位表示形式就能转换回来。 例如，可以在 x86 上提升为int的任何类型（例如，在 x64 上长长的时间）（例如， char或short）或可以强制转换为int的类型（在 x64 上长长），并返回到不带更改的原始类型是整数类型。 整数类型包括指针、引用和结构或4个字节的联合类型（x64 上的8个字节）或更少。 在 x64 平台上，更大的结构和联合类型通过引用传递给调用方分配的内存;在 x86 平台上，它们通过堆栈上的值进行传递。 矢量类型为浮点类型（例如， float或DOUBLE）或 SIMD 矢量类型，例如 __m128或 __m256。 HVA 类型是复合类型，包含四个具有相同矢量类型的数据成员。 HVA 类型具有和其成员的矢量类型相同的对齐需求。 下面一个包含三个相同向量类型并且具有32字节对齐方式的 HVA结构定义的示例： 12345typedef struct { __m256 x; __m256 y; __m256 z;} hva3; // 3 element HVA type on __m256 __vectorcall对于加速运算速度（尤其是图形学中涉及到大量4维矩阵和向量的计算，能大幅度提升运算速度。它的名称约定如下： 声明为 int func( int a, double b ) 的函数按如下所示进行修饰：_func@@12 (int + double的字节数) 其实以上调用规定在很多情况下可以通过修改编译器参数进行设置。下面从msdn上复制一段描述： 备注默认设置“/Gd”为除 C++ 成员函数和标记为 __stdcall、__fastcall 或 __vectorcall 的函数之外的所有函数指定 __cdecl 调用约定。 “/Gr”为除 C++ 成员函数、名为 main 的函数以及标记为 __cdecl、__stdcall 或 __vectorcall 的函数之外的所有函数指定 __fastcall 调用约定。 所有 __fastcall 函数都必须有原型。 此调用约定仅在面向 x86 的编译器中可用，在面向其他体系结构的编译器中被忽略。 “/Gz”为除 C++ 成员函数、名为 main 的函数以及标记为 __cdecl、__fastcall 或 __vectorcall 的函数之外的所有函数指定 __stdcall 调用约定。 所有 __stdcall 函数都必须有原型。 此调用约定仅在面向 x86 的编译器中可用，在面向其他体系结构的编译器中被忽略。 /Gv为除成员函数、名为 main的C++函数、具有 vararg 变量参数列表的函数或标记为冲突的 cdecl、stdcall或 fastcall 特性的函数之外的所有函数指定 vectorcall 调用约定。 此调用约定仅在支持 /arch:SSE2 及更高版本的 x86 和 x64 体系结构上可用，并且被面向 ARM 架构的编译器忽略。 采用可变数量参数的函数必须标记为 __cdecl。 /Gd、/Gr、/Gv 和 /Gz 与 /clr:safe 或 /clr:pure 不兼容。 “/clr:pure”和“/clr:safe”编译器选项在 Visual Studio 2015 中已弃用，并且在 Visual Studio 2017 和更高版本中不受支持。 对于非静态类函数，如果函数是超行定义的，则调用约定修饰符不必在超行定义中指定。 也就是说，对于类非静态成员方法，在定义时假定声明期间指定的调用约定。 补充：例如在vulkan1.2版本的&lt;vk_platform.h&gt;头文件中有如下代码： 12345678910111213141516171819/* Platform-specific calling convention macros. * * Platforms should define these so that Vulkan clients call Vulkan commands * with the same calling conventions that the Vulkan implementation expects. * * VKAPI_ATTR - Placed before the return type in function declarations. * Useful for C++11 and GCC/Clang-style function attribute syntax. * VKAPI_CALL - Placed after the return type in function declarations. * Useful for MSVC-style calling convention syntax. * VKAPI_PTR - Placed between the &apos;(&apos; and &apos;*&apos; in function pointer types. * * Function declaration: VKAPI_ATTR void VKAPI_CALL vkCommand(void); * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void); */#if defined(_WIN32) // On Windows, Vulkan commands use the stdcall convention #define VKAPI_ATTR #define VKAPI_CALL __stdcall #define VKAPI_PTR VKAPI_CALL 可以看到，vulkan针对于windows平台，定义了VKAPI_CALL宏，实际上它就是__stdcall 相关链接：https://docs.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2019","link":"/2020/05/01/index/"}],"tags":[],"categories":[]}