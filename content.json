{"pages":[{"title":"C++的函数调用约定(calling convention)","text":"我们在C++中调用函数时，可能很少关注参数是如何入栈，在调用完毕之后又是如何恢复栈的状态的。实际上我们可以通过 对于VC++编译器来说，支持下列的调用约定： 关键字 堆栈清理 参数传递 __cdecl 调用方 在堆栈上按相反顺序推送参数（从右到左） __clrcall 不适用 按顺序将参数加载到 CLR 表达式堆栈上（从左到右） __stdcall 被调用方 在堆栈上按相反顺序推送参数（从右到左） __fastcall 被调用方 存储在寄存器中，然后在堆栈上推送 __thiscall 被调用方 已推送到堆栈上;此指针存储在 ECX 中 _vectorcall 被调用方 存储在寄存器中，然后按相反顺序在堆栈上推送（从右到左） 下面分别简单介绍一下上述六个调用约定： __cdecl__cdecl是 C 和C++程序的默认调用约定。 堆栈由调用方清理，所以参数就可以是vararg。__cdecl名称约定如下： int func( int a, double b ) 的函数按如下所示进行修饰：_func 在 ARM 和 x64 处理器上 ，__cdecl被编译器接受，但通常被忽略掉。 按照 ARM 和 x64 上的约定，自变量将尽可能传入寄存器，后续自变量传递到堆栈中（毕竟寄存器就那么几个，对于参数非常多的函数，不得不把一部分参数压到栈中）。 在 x64 代码中，使用 __cdecl来重写 /Gv编译器选项并使用默认 x64 调用约定。 123456789//定义如下结构struct CMyClass { void __cdecl mymethod();};//functionAvoid CMyClass::mymethod() { return; }//functionBvoid __cdecl CMyClass::mymethod() { return; }//functionB 和functionA是等价的 __clrcall__clrcall是微软对C++做的扩展，通过它可以让C++调用C#的函数。通过启用编译器参数(/clr)，可以将所有的函数和函数指针标记。 123456789101112131415161718192021222324252627282930// clrcall2.cpp// compile with: /clrusing namespace System;int __clrcall Func1() { Console::WriteLine(&quot;in Func1&quot;); return 0;}// Func1 hasn&apos;t been used at this point (code has not been generated),// so runtime returns the adddress of a stub to the functionint (__clrcall *pf)() = &amp;Func1;// code calls the function, code generated at difference addressint i = pf(); // comment this line and comparison will passint main() { if (&amp;Func1 == pf) Console::WriteLine(&quot;&amp;Func1 == pf, comparison succeeds&quot;); else Console::WriteLine(&quot;&amp;Func1 != pf, comparison fails&quot;); // even though comparison fails, stub and function call are correct pf(); Func1();}//输出//in Func1//&amp;Func1 != pf, comparison fails//in Func1//in Func1 __stdcall__stdcall一般用于WINAPI中。stdcall是不支持可变参数的。它的名称约定如下： 下划线 () 是名称的前缀。 名称后跟后面是自变量列表中的字节数（采用十进制）的符号 (@)。 因此，声明为 int func( int a, double b ) 的函数按如下所示进行修饰：_func@12 (int + double的字节数) __fastcall__fastcall仅适用于x86架构。面向 ARM 和 x64 体系结构的编译器接受并忽略该关键字;在 x64 芯片上，按照约定，前四个参数在寄存器中传递（如果可能），而其他参数在堆栈上传递。 在 ARM 芯片上，寄存器中可以传递最多四个整数参数和八个浮点参数，而其他参数在堆栈上传递。它的名称约定如下： 声明为 int func( int a, double b ) 的函数按如下所示进行修饰：@func@12 (int + double的字节数) __thiscall__thiscall在 ARM 和 x64 计算机上，编译器接受并忽略它。它由被调用方清理堆栈，自然不支持可变参数。因为C++的类成员函数和其他的函数不同的一点在于成员都有一个this指针，为了处理这种情况，会用到thiscall。 __vectorcall__vectorcall默认也是尽可能多地使用寄存器。相比于fastcall或x64调用约定，它会使用更多的寄存器。但是仅在包含流式处理 SIMD 扩展2（SSE2）和更高版本的 x86 和 x64 处理器上的本机代码中支持 vectorcall调用约定。 使用 vectorcall**加快传递多个浮点或 SIMD 向量参数的函数，并执行利用寄存器中加载的参数的操作。 __vectorcall对于参数类型有严格的要求，具体如下： 可以通过在 __vectorcall函数中注册来传递三种参数：整数类型值、矢量类型值和同类矢量聚合（HVA）值。 整数类型满足两个要求：它适合处理器的本机寄存器大小（例如，x86 计算机上的 4 个字节或 x64 计算机上的 8 个字节），而且它可以转换成与寄存器长度一样的整数，并且不用更改其位表示形式就能转换回来。 例如，可以在 x86 上提升为int的任何类型（例如，在 x64 上长长的时间）（例如， char或short）或可以强制转换为int的类型（在 x64 上长长），并返回到不带更改的原始类型是整数类型。 整数类型包括指针、引用和结构或4个字节的联合类型（x64 上的8个字节）或更少。 在 x64 平台上，更大的结构和联合类型通过引用传递给调用方分配的内存;在 x86 平台上，它们通过堆栈上的值进行传递。 矢量类型为浮点类型（例如， float或DOUBLE）或 SIMD 矢量类型，例如 __m128或 __m256。 HVA 类型是复合类型，包含四个具有相同矢量类型的数据成员。 HVA 类型具有和其成员的矢量类型相同的对齐需求。 下面一个包含三个相同向量类型并且具有32字节对齐方式的 HVA结构定义的示例： 12345typedef struct { __m256 x; __m256 y; __m256 z;} hva3; // 3 element HVA type on __m256 __vectorcall对于加速运算速度（尤其是图形学中涉及到大量4维矩阵和向量的计算，能大幅度提升运算速度。它的名称约定如下： 声明为 int func( int a, double b ) 的函数按如下所示进行修饰：_func@@12 (int + double的字节数) 其实以上调用规定在很多情况下可以通过修改编译器参数进行设置。下面从msdn上复制一段描述： 备注默认设置“/Gd”为除 C++ 成员函数和标记为 __stdcall、__fastcall 或 __vectorcall 的函数之外的所有函数指定 __cdecl 调用约定。 “/Gr”为除 C++ 成员函数、名为 main 的函数以及标记为 __cdecl、__stdcall 或 __vectorcall 的函数之外的所有函数指定 __fastcall 调用约定。 所有 __fastcall 函数都必须有原型。 此调用约定仅在面向 x86 的编译器中可用，在面向其他体系结构的编译器中被忽略。 “/Gz”为除 C++ 成员函数、名为 main 的函数以及标记为 __cdecl、__fastcall 或 __vectorcall 的函数之外的所有函数指定 __stdcall 调用约定。 所有 __stdcall 函数都必须有原型。 此调用约定仅在面向 x86 的编译器中可用，在面向其他体系结构的编译器中被忽略。 /Gv为除成员函数、名为 main的C++函数、具有 vararg 变量参数列表的函数或标记为冲突的 cdecl、stdcall或 fastcall 特性的函数之外的所有函数指定 vectorcall 调用约定。 此调用约定仅在支持 /arch:SSE2 及更高版本的 x86 和 x64 体系结构上可用，并且被面向 ARM 架构的编译器忽略。 采用可变数量参数的函数必须标记为 __cdecl。 /Gd、/Gr、/Gv 和 /Gz 与 /clr:safe 或 /clr:pure 不兼容。 “/clr:pure”和“/clr:safe”编译器选项在 Visual Studio 2015 中已弃用，并且在 Visual Studio 2017 和更高版本中不受支持。 对于非静态类函数，如果函数是超行定义的，则调用约定修饰符不必在超行定义中指定。 也就是说，对于类非静态成员方法，在定义时假定声明期间指定的调用约定。 补充：例如在vulkan1.2版本的&lt;vk_platform.h&gt;头文件中有如下代码： 12345678910111213141516171819/* Platform-specific calling convention macros. * * Platforms should define these so that Vulkan clients call Vulkan commands * with the same calling conventions that the Vulkan implementation expects. * * VKAPI_ATTR - Placed before the return type in function declarations. * Useful for C++11 and GCC/Clang-style function attribute syntax. * VKAPI_CALL - Placed after the return type in function declarations. * Useful for MSVC-style calling convention syntax. * VKAPI_PTR - Placed between the &apos;(&apos; and &apos;*&apos; in function pointer types. * * Function declaration: VKAPI_ATTR void VKAPI_CALL vkCommand(void); * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void); */#if defined(_WIN32) // On Windows, Vulkan commands use the stdcall convention #define VKAPI_ATTR #define VKAPI_CALL __stdcall #define VKAPI_PTR VKAPI_CALL 可以看到，vulkan针对于windows平台，定义了VKAPI_CALL宏，实际上它就是__stdcall 相关链接：https://docs.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2019","link":"/C-%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-calling-convention/index.html"}],"posts":[{"title":"GoogleTest和GoogleMock的基本概念","text":"gMock 是一个C++的mock库。 熟悉其他编程语言的人也许知道，Java和Python等编程语言都有常用的Mock工具（例如jMock，EasyMock，Mox等）。而gMock正是一个C++的mock库。我认为，一位编程人员在自己编写程序的时候能够同时把单元测试（为了自己，也为了不麻烦别人）做好是一件很棒的事情。对于C++，业界常用的mock工具之一就是gMock了。","link":"/2020/05/24/GoogleTest%E5%92%8CGoogleMock%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/30/hello-world/"},{"title":"使用std::futured的并行快速排序算法","text":"快速排序算法我们或多或少都曾了解过。但我们使用的一般都是单线程的版本，对于小规模的数据，尚且可以应付。而对于大规模的数据，单线程的版本就有些力不从心，就为了研究并行的快速排序算法，我们不妨先回顾一下传统的快速排序算法。下面首先用Haskell简单阐述一下基本的快排原理。 代码如下： 12345quicksort [] = []quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater) ``where ``lesser = ``filter` `(&lt; p) xs ``greater = ``filter` `(&gt;= p) xs 为了实现快速排序算法，我们需要选择一个基准元素p，将当前数组分为两个子数组，其中lesser数组里面存放小于基准元素p的所有元素，greater存放剩下的元素。递归执行。 仿照上述Haskell代码，我们写出以下C++代码： 123456789101112131415161718192021222324252627template &lt;typename T&gt;void quick_sort(vector&lt;T&gt;&amp; v) { if (v.size() &lt;= 1) return; auto start_it = v.begin(); auto end_it = v.end(); const T pivot = *start_it;//partition the list vector&lt;T&gt; lesser; copy_if(start_it, end_it, std::back_inserter(lesser), [&amp;](const T&amp; el) { return el &lt; pivot; }); vector&lt;T&gt; greater; copy_if(start_it + 1, end_it, std::back_inserter(greater), [&amp;](const T&amp; el) { return el &gt;= pivot; });//solve subproblems quick_sort(lesser); quick_sort(greater);//merge std::copy(lesser.begin(), lesser.end(), v.begin()); v[lesser.size()] = pivot; std::copy(greater.begin(), greater.end(), v.begin() + lesser.size() + 1);} 在C++中，函数式编程常用的filter函数对应于中的copy_if函数。定义如下： 123template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt; OutputIterator copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred); 前两个参数分别是容器的头尾迭代器，第三个参数是输出结果的迭代器，最后一个是判断条件。在上述quick_sort函数中，我们用lambda实现了对数组各元组与基准元素的判断。再用递归对子数组调用算法。最后把各个子数组进行合并。 那么如何用并行的方式去计算快排呢？ 我们很容易分析出，在每一个层递归的函数中，计算lesser与greater是完全独立的两个过程。根据这个原理，我们就可以设计我们的并行快排。 我们尝试用C++的去实现这种思想 12345678910111213141516171819202122232425262728293031323334template &lt;typename T&gt;void filter(const vector&lt;T&gt;&amp; v, vector&lt;T&gt;&amp; lesser, const int pivot) { for (const auto el : v) { if (el &lt; pivot) lesser.push_back(el); }}template &lt;typename T&gt;void quick_sort(vector&lt;T&gt;&amp; v) { if (v.size() &lt;= 1) return; auto start_it = v.begin(); auto end_it = v.end(); const T pivot = *start_it; vector&lt;T&gt; lesser; auto fut1 = std::async([&amp;]() { filter&lt;T&gt;(std::ref(v), std::ref(lesser), pivot); quick_sort&lt;T&gt;(std::ref(lesser)); }); vector&lt;T&gt; greater; copy_if(start_it + 1, end_it, std::back_inserter(greater), [&amp;](const T&amp; el) { return el &gt;= pivot; }); quick_sort(greater); fut1.wait(); std::copy(lesser.begin(), lesser.end(), v.begin()); v[lesser.size()] = pivot; std::copy(greater.begin(), greater.end(), v.begin() + lesser.size() + 1);} 上述并行算法在每一次将小于基准元素的数组放到lesser的操作时，创建了一个新的线程，并在当前的线程执行greater的操作。为了更明白地展示算法，线程与子数组的关系参考下图 其中虚线代表子数组由分配的新线程计算，而实线代表子数组由当前线程。 最后在执行完greater后等待子线程完成计算并合并。 从理论上来说，我们已经通过引入多个线程并行计算达到节约计算时间的效果，但实际上对于较小的数组来说，上述并行算法反而会耗时更多，原因在于开辟新的线程并维护上下文的代价是很大的。上述算法即使在子问题很小的时候也会开辟新的线程，这是很耗时也没有必要的。事实上一定是有这样一个阈值，当子问题规模小于该阈值时，开辟新线程异步的代价要比在单一线程计算要耗时。 一个简单但实用的解决方法时，我们不妨设置一个阈值，小于该阈值就用单线程计算就好了。具体代码如下： template void filter(const vector&amp; v, vector&amp; lesser, const int pivot) { for (const auto el : v) { if (el &lt; pivot) lesser.push_back(el); }} template void quick_sort_async_lim(vector&amp; v) { if (v.size() &lt;= 1) return; auto start_it = v.begin(); auto end_it = v.end(); 12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;typename T&gt;void filter(const vector&lt;T&gt;&amp; v, vector&lt;T&gt;&amp; lesser, const int pivot) { for (const auto el : v) { if (el &lt; pivot) lesser.push_back(el); }}template &lt;typename T&gt;void quick_sort_async_lim(vector&lt;T&gt;&amp; v) { if (v.size() &lt;= 1) return; auto start_it = v.begin(); auto end_it = v.end(); const T pivot = *start_it; vector&lt;T&gt; lesser; vector&lt;T&gt; greater; copy_if(start_it + 1, end_it, std::back_inserter(greater), [&amp;](const T&amp; el) { return el &gt;= pivot; }); if (v.size() &gt;= THRESHOLD) { auto fut1 = std::async([&amp;]() { filter&lt;T&gt;(std::ref(v), std::ref(lesser), pivot); quick_sort_async_lim&lt;T&gt;(std::ref(lesser)); }); quick_sort_async_lim(greater); fut1.wait(); } else { //子问题很小，没必要开辟新的线程 copy_if(start_it, end_it, std::back_inserter(lesser), [&amp;](const T&amp; el) { return el &lt; pivot; }); quick_sort_async_lim(lesser); quick_sort_async_lim(greater); } std::copy(lesser.begin(), lesser.end(), v.begin()); v[lesser.size()] = pivot; std::copy(greater.begin(), greater.end(), v.begin() + lesser.size() + 1);} 现在，我们的并行快排算法在处理问题的时候就可以充分应用到多线程的优势了。当然，我们目前的代码依然还有很多可以改进的地方，比如我们可以限制我们的最大线程数小于物理上CPU支持的最大线程数（对于支持超线程技术的CPU来说，一般为核心数X2），还可以对于子问题进行进一步的划分，比如对于非常小的子问题不采用快排而采用插入排序等。但无论如何，我们的核心思想至少已经得到了体现。","link":"/2020/06/05/%E4%BD%BF%E7%94%A8std-futured%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"C++的函数调用约定(calling convention)","text":"我们在C++中调用函数时，可能很少关注参数是如何入栈，在调用完毕之后又是如何恢复栈的状态的。实际上我们可以通过 对于VC++编译器来说，支持下列的调用约定： 关键字 堆栈清理 参数传递 __cdecl 调用方 在堆栈上按相反顺序推送参数（从右到左） __clrcall 不适用 按顺序将参数加载到 CLR 表达式堆栈上（从左到右） __stdcall 被调用方 在堆栈上按相反顺序推送参数（从右到左） __fastcall 被调用方 存储在寄存器中，然后在堆栈上推送 __thiscall 被调用方 已推送到堆栈上;此指针存储在 ECX 中 _vectorcall 被调用方 存储在寄存器中，然后按相反顺序在堆栈上推送（从右到左） 下面分别简单介绍一下上述六个调用约定： __cdecl__cdecl是 C 和C++程序的默认调用约定。 堆栈由调用方清理，所以参数就可以是vararg。__cdecl名称约定如下： int func( int a, double b ) 的函数按如下所示进行修饰：_func 在 ARM 和 x64 处理器上 ，__cdecl被编译器接受，但通常被忽略掉。 按照 ARM 和 x64 上的约定，自变量将尽可能传入寄存器，后续自变量传递到堆栈中（毕竟寄存器就那么几个，对于参数非常多的函数，不得不把一部分参数压到栈中）。 在 x64 代码中，使用 __cdecl来重写 /Gv编译器选项并使用默认 x64 调用约定。 123456789//定义如下结构struct CMyClass { void __cdecl mymethod();};//functionAvoid CMyClass::mymethod() { return; }//functionBvoid __cdecl CMyClass::mymethod() { return; }//functionB 和functionA是等价的 __clrcall__clrcall是微软对C++做的扩展，通过它可以让C++调用C#的函数。通过启用编译器参数(/clr)，可以将所有的函数和函数指针标记。 123456789101112131415161718192021222324252627282930// clrcall2.cpp// compile with: /clrusing namespace System;int __clrcall Func1() { Console::WriteLine(&quot;in Func1&quot;); return 0;}// Func1 hasn&apos;t been used at this point (code has not been generated),// so runtime returns the adddress of a stub to the functionint (__clrcall *pf)() = &amp;Func1;// code calls the function, code generated at difference addressint i = pf(); // comment this line and comparison will passint main() { if (&amp;Func1 == pf) Console::WriteLine(&quot;&amp;Func1 == pf, comparison succeeds&quot;); else Console::WriteLine(&quot;&amp;Func1 != pf, comparison fails&quot;); // even though comparison fails, stub and function call are correct pf(); Func1();}//输出//in Func1//&amp;Func1 != pf, comparison fails//in Func1//in Func1 __stdcall__stdcall一般用于WINAPI中。stdcall是不支持可变参数的。它的名称约定如下： 下划线 () 是名称的前缀。 名称后跟后面是自变量列表中的字节数（采用十进制）的符号 (@)。 因此，声明为 int func( int a, double b ) 的函数按如下所示进行修饰：_func@12 (int + double的字节数) __fastcall__fastcall仅适用于x86架构。面向 ARM 和 x64 体系结构的编译器接受并忽略该关键字;在 x64 芯片上，按照约定，前四个参数在寄存器中传递（如果可能），而其他参数在堆栈上传递。 在 ARM 芯片上，寄存器中可以传递最多四个整数参数和八个浮点参数，而其他参数在堆栈上传递。它的名称约定如下： 声明为 int func( int a, double b ) 的函数按如下所示进行修饰：@func@12 (int + double的字节数) __thiscall__thiscall在 ARM 和 x64 计算机上，编译器接受并忽略它。它由被调用方清理堆栈，自然不支持可变参数。因为C++的类成员函数和其他的函数不同的一点在于成员都有一个this指针，为了处理这种情况，会用到thiscall。 __vectorcall__vectorcall默认也是尽可能多地使用寄存器。相比于fastcall或x64调用约定，它会使用更多的寄存器。但是仅在包含流式处理 SIMD 扩展2（SSE2）和更高版本的 x86 和 x64 处理器上的本机代码中支持 vectorcall调用约定。 使用 vectorcall**加快传递多个浮点或 SIMD 向量参数的函数，并执行利用寄存器中加载的参数的操作。 __vectorcall对于参数类型有严格的要求，具体如下： 可以通过在 __vectorcall函数中注册来传递三种参数：整数类型值、矢量类型值和同类矢量聚合（HVA）值。 整数类型满足两个要求：它适合处理器的本机寄存器大小（例如，x86 计算机上的 4 个字节或 x64 计算机上的 8 个字节），而且它可以转换成与寄存器长度一样的整数，并且不用更改其位表示形式就能转换回来。 例如，可以在 x86 上提升为int的任何类型（例如，在 x64 上长长的时间）（例如， char或short）或可以强制转换为int的类型（在 x64 上长长），并返回到不带更改的原始类型是整数类型。 整数类型包括指针、引用和结构或4个字节的联合类型（x64 上的8个字节）或更少。 在 x64 平台上，更大的结构和联合类型通过引用传递给调用方分配的内存;在 x86 平台上，它们通过堆栈上的值进行传递。 矢量类型为浮点类型（例如， float或DOUBLE）或 SIMD 矢量类型，例如 __m128或 __m256。 HVA 类型是复合类型，包含四个具有相同矢量类型的数据成员。 HVA 类型具有和其成员的矢量类型相同的对齐需求。 下面一个包含三个相同向量类型并且具有32字节对齐方式的 HVA结构定义的示例： 12345typedef struct { __m256 x; __m256 y; __m256 z;} hva3; // 3 element HVA type on __m256 __vectorcall对于加速运算速度（尤其是图形学中涉及到大量4维矩阵和向量的计算，能大幅度提升运算速度。它的名称约定如下： 声明为 int func( int a, double b ) 的函数按如下所示进行修饰：_func@@12 (int + double的字节数) 其实以上调用规定在很多情况下可以通过修改编译器参数进行设置。下面从msdn上复制一段描述： 备注默认设置“/Gd”为除 C++ 成员函数和标记为 __stdcall、__fastcall 或 __vectorcall 的函数之外的所有函数指定 __cdecl 调用约定。 “/Gr”为除 C++ 成员函数、名为 main 的函数以及标记为 __cdecl、__stdcall 或 __vectorcall 的函数之外的所有函数指定 __fastcall 调用约定。 所有 __fastcall 函数都必须有原型。 此调用约定仅在面向 x86 的编译器中可用，在面向其他体系结构的编译器中被忽略。 “/Gz”为除 C++ 成员函数、名为 main 的函数以及标记为 __cdecl、__fastcall 或 __vectorcall 的函数之外的所有函数指定 __stdcall 调用约定。 所有 __stdcall 函数都必须有原型。 此调用约定仅在面向 x86 的编译器中可用，在面向其他体系结构的编译器中被忽略。 /Gv为除成员函数、名为 main的C++函数、具有 vararg 变量参数列表的函数或标记为冲突的 cdecl、stdcall或 fastcall 特性的函数之外的所有函数指定 vectorcall 调用约定。 此调用约定仅在支持 /arch:SSE2 及更高版本的 x86 和 x64 体系结构上可用，并且被面向 ARM 架构的编译器忽略。 采用可变数量参数的函数必须标记为 __cdecl。 /Gd、/Gr、/Gv 和 /Gz 与 /clr:safe 或 /clr:pure 不兼容。 “/clr:pure”和“/clr:safe”编译器选项在 Visual Studio 2015 中已弃用，并且在 Visual Studio 2017 和更高版本中不受支持。 对于非静态类函数，如果函数是超行定义的，则调用约定修饰符不必在超行定义中指定。 也就是说，对于类非静态成员方法，在定义时假定声明期间指定的调用约定。 补充：例如在vulkan1.2版本的&lt;vk_platform.h&gt;头文件中有如下代码： 12345678910111213141516171819/* Platform-specific calling convention macros. * * Platforms should define these so that Vulkan clients call Vulkan commands * with the same calling conventions that the Vulkan implementation expects. * * VKAPI_ATTR - Placed before the return type in function declarations. * Useful for C++11 and GCC/Clang-style function attribute syntax. * VKAPI_CALL - Placed after the return type in function declarations. * Useful for MSVC-style calling convention syntax. * VKAPI_PTR - Placed between the &apos;(&apos; and &apos;*&apos; in function pointer types. * * Function declaration: VKAPI_ATTR void VKAPI_CALL vkCommand(void); * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void); */#if defined(_WIN32) // On Windows, Vulkan commands use the stdcall convention #define VKAPI_ATTR #define VKAPI_CALL __stdcall #define VKAPI_PTR VKAPI_CALL 可以看到，vulkan针对于windows平台，定义了VKAPI_CALL宏，实际上它就是__stdcall 相关链接：https://docs.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2019","link":"/2020/05/01/index/"}],"tags":[],"categories":[]}